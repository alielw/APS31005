# Introduction to the HPC

The aim of this practical is to get you started using the HPC.

## 1. Running jobs interactively

If you are on a worker node you will see the name of the node, eg.
```
[bo1nn@sharc-node004 ~]$
```

If not then request an interactive session:
```bash
qrsh
```

We can run small jobs on interactive sessions. You can configure the resources available to the interactive session by adding command line options. For example to start an interactive session with access to 16 GB of RAM:
```
bo1nn@sharc-login1 ~]$ qrsh -l rmem=16G
```
or
To start a session with access to 2 cores:
```
bo1nn@sharc-login1 ~]$ qrsh -pe smp 2
```
We will use the interactive session for ```plink```. We will cover this tomorrow.

Type
```
plink
```


## 2. Running batch jobs

Let's make a file called ```firstjob.sh``` in your ```test``` folder.

Open it using ```nano firstjob.sh```

The first line always needs to be ```#!/bin/bash```

You request time with ```#$ -l h_rt=00:00:00```
Note, the upper limit is typically 96:00:00 (4 days)

You request nodes with ```#$ -pe smp 1```

You request memory with ```#$ -l rmem=0G```
For SGE (ShARC), -l rmem=xxG is used to specify the maximum amount (xx) of real memory to be requested per CPU core.

Job name, used to name output files and in the queue list. ```#$ -N firstjob```

The script will produce log output and error files
```#$ -e firstjob.errorlog```
```#$ -o firstjob.txt```

So the start of your ```.sh``` file should look like this:
```
#!/bin/bash
#$ -l h_rt=00:01:00
#$ -l rmem=1G
#$ -pe smp 1
#$ -N firstjob
#$ -e firstjob.errorlog
#$ -o firstjob.txt
```

Then we want to tell the job to run it on our reserved nodes.
```
#$ -P aps31005
#$ -q aps31005.q
```

Then we specify the job we want to run
```
echo "Hello World"
```

So, your job should look like this

```
#!/bin/bash
#$ -l h_rt=00:01:00
#$ -l rmem=1G
#$ -pe smp 1
#$ -N test
#$ -e firstjob.errorlog
#$ -o firstjob.txt

#$ -P aps31005
#$ -q aps31005.q

echo "started"
date

echo "Hello World"

echo "finished"
date
```

Then we submit the job with
```
qsub test.sh
```

We can check the status of the job with ```qstat```

You should see something like this:
```
job-ID  prior   name       user         state submit/start at     queue                          slots ja-task-ID
-----------------------------------------------------------------------------------------------------------------
3528787 0.02478 QRLOGIN    bo1nn        r     02/16/2019 15:55:41 interactive.q@sharc-node003.sh     1
3528789 0.00003 firstjob.sh bo1nn        qw     02/16/2019 15:58:35 all.q@sharc-node073.shef.ac.uk     1
```

```qw``` - Job has been submitted and is waiting in the queue.

```Eqw``` - Job has been submitted but an error is preventing job from starting.

```r``` - Job is currently running.

```qdel <job ID>``` will kill the job

Often it's best to check if the job will actually run before you submit it, incase you accidentally request too many resources

```qsub -w v firstjob.sh```

You should get
```verification: found suitable queue(s)```

Let's look at the output files now, are they what you expect?

